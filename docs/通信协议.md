# 电气设备检测装置通信协议

|修订版本|	修订日期    |    修订内容                    |	修订人|
|  ---  |   ----       |      ---                       |  ---   |
| v1.1.1  |	2022-07-16 |	重新确定轮询时屏蔽方式   |张頔  |
| v1.1  |	2022-07-09 |	对气体传感器轮询方式及时间间隔做具体规定   |张頔  |
| v1.0.1  |	2022-03-01 |	加入传感器数量修改内容   |张頔  |
| v1.0  |	2022-02-25 |	修改传感器读取延时，初版发布   |张頔  |
| v0.5.8  |	2022-02-25 |	对传感器异常值做出规定   |张頔  |
| v0.5.7  |	2022-02-25 |	加入每个传感器通信超时设置   |张頔  |
| v0.5.6  |	2022-02-25 |	加入每个传感器的地址和对应CRC校验码   |张頔  |
| v0.5.5  |	2022-02-24 |	补充CRC使用细节                |张頔  |
| v0.5.4  |	2022-02-24 |	规定单片机和传感器之间的应答流程 |张頔  |
| v0.5.3  |	2022-02-24 |	加入CRC校验方法                |张頔  |
| v0.5  |	2022-02-21 |	与有害气体传感器通信协议数据帧详细格式|张頔  |
| v0.4  |	2022-02-19 |	下位机与传感器通信方式定为软串口|张頔  |
| v0.3  |	2022-02-18 |	重新整理通信协议，移去身份识别，全部采用字节发送，json调整为上位机解析规范|张頔  |
| v0.2.6  |	2022-02-16 |	精简协议，去除i_name            |易才润|
| v0.2.5  |	2022-02-13 |	加入字节编码内容，明确时间间隔查询方式  |张頔|
| v0.2.4  |	2022-02-13 |	字节择掉时间间隔，加入查询命令  |张頔|
| v0.2.3  |	2022-02-13 |	上位机系统身份识别  |张頔|
| v0.2.2  |	2022-02-13 |	删去ESP时间戳，精简下发上，加地址位  |张頔|
| v0.2.1  |	2022-02-12 |	安卓端20字节待解决，及小改  |张頔|
| v0.2.0  |	2022-02-10 |	确定下发上内容并精简，补充上发下格式     |张頔|
| v0.1.6  |	2022-02-10 |	订正字典结构格式            	        |张頔|
| v0.1.5  |	2022-02-10 |	提出代码json格式错误，加入真实时间戳	|易才润|
| v0.1.2  |	2022-02-09 |	氮氧化物细分为一氧化氮和二氧化氮，精简名称	|张頔|
| v0.1.1  |	2022-02-09 |	加入发信字符串最大长度限制	|张頔|
| v0.1  |	2022-02-08 |	初始版本，定义了下位机传回数据格式	|张頔|

    本通信协议包含一下几部分通信内容的规定：
    
    （1）蓝牙下位机向上位机传输的数据格式和涵盖的基本内容；
    
    （2）上位机对下位机数据解析规范；
    
    （3）上位机向下位机发指令的内容及其基本格式；
    
    （4）硬件内部通信和上下位机部分全局变量说明；
    
    （5）有害气体传感器通信协议。

---

## 一、 下位机发信协议

下位机发送的数据格式为`uint8`（`char`型）数据构成的字符串，由于安卓手机默认蓝牙通信每个数据包最大值为`20`，因此本通信协议将所有数据压缩至不超过`20`个字节之内，数据内严格按照顺序和其占位数量排列每个字节。发信的字节顺序是：数据数量、地址、和具体数据。对于上位机单独询问时间间隔的指令，会单独进行异步回复。

### 1.1 下位机发送数据格式

定期发送的数据包中字节的顺序严格与表格顺序相同。

表1 字节位数与项目对应

|键名|	 字节数  |	         含义       |
|---:|  :---:   |---                   |
i_num|	1       |	        包含数据条数
add |	1       |     	    当前传回参数的从机地址
plm_s|  2       |           当前数据传回时间间隔
temp|	2       |	        温度
humi|	2       |	        湿度
NH3 |	2       |	        氨气浓度
O3  |	2       |	        臭氧浓度
NO  |	2       |	        氮氧化物浓度
NO2 |	2       |	        氮氧化物浓度

（1）时间间隔

- 由高低两个字节构成，可设置的时间间隔为`500`毫秒至`65535`毫秒。

（2）温湿度

- 对于温湿度，高字节为整数部分，低字节为小数部分，若为负数则两个都是`0`。

（3）气体传感器

- 高字节和低字节共同组成要传的数，收到之后再乘以分辨率`0.1ppm`。
- 异常数据格式与温湿度不同，是两个`0xFF`。

（4）发送数据条数和地址

- 值得注明的是，这两条数据是字符型的数字，取值`'0'~'9'`；而除开单独回复时间间隔这一种情况，包含的数据条数是**不少于**`2`的。

#### **发信样例demo：**

```C++
"2" "1" 0x03 0xe8 0x17 0x02 0x0f 0x00 // 传回2条数据，地址位为1，时间间隔为1000毫秒，温度为23.2，湿度为15.0
"3" "1" 0x03 0xe8 0x00 0x00 0x00 0x00 0x01 0x01// 传回3条数据，地址位为1，时间间隔为1000毫秒，温湿度传感器工作异常，氨气浓度25.7ppm = (1*256+1)*0.1
```

（5）时间间隔

对于单独回复的时间间隔，传输的格式特别限定，传回数据数目为`1`，这时候就是时间间隔，数据位为当前的`period_millis`。

```C++
"11500" // 传回1条数据，地址位为1，时间间隔为500毫秒
"111000" // 同上，时间间隔为1000毫秒
```


## 二、上位机解析数据格式

数据格式为一个`Json`结构，最外层为一个大括号，内部每个键后跟冒号，再跟键值，键值末端以**逗号**结尾，最后一个键值无逗号结尾，全部键用引号括起来，键值若为包含多个子字符串的字符串数组则用**中括号**括起来，内部每个键用**引号**括起来，中间用**逗号**隔开，数字保留原始状态。字典深度为`1`，即仅有最外层一个大括号。

### 2.1 数据内容

字典内包括数据条数，当前采样时间间隔，当前从机地址，传感器具体数据等。在收到之后加入实时时间戳。

**特别说明**，组成`json`的字符串内，相应键必须严格与下列顺序一致，因为在传回的条目名称中，传感器的数量是与下表相同的顺序相叠加，分最基础的温湿度+氨气直到全部传感器。若赋予了某特定传感器但并未检测到连接，则会返回`-1`作为测量量。下面对每一条详细说明。

表2 键名与键值数据类型对应及含义简要介绍

|键名|	 键值类型|	含义|
|---:|  :---:   |---   |
i_num|	int   |	        包含数据条数
p_mls|	uint16|	传感器采样时间间隔，单位毫秒
add |	int   |     	当前传回参数从机地址
temp|	float |	        温度
humi|	float |	        湿度
NH3 |	float |	        氨气浓度
O3  |	float |	        臭氧浓度
NO  |	float |	        一氧化氮浓度
NO2 |	float |	        二氧化氮浓度


（1）包含数据条数 i_num

- 即传回信息中包含数据条目的总数，用来辅助分割条目名称的字符串段，数据类型为`int`。

（2）当前采样时间间隔 p_mls

- 采样时间间隔，数据类型为`uint16`，推荐默认采样间隔时长为`1000`毫秒。实际存储应用`long`或`unsigned long`。

（3）地址 add

- 标记当前传回数据的从机的地址位，数据类型为`int`。在早期测试中，仅有一台从机工作，此地址位留给未来多台从机组网构建蓝牙mesh用，长度为`1`个字节。

（4）其他若干数据

- 本传感器检测的数据包括**一氧化氮浓度**、**二氧化氮浓度**、**臭氧浓度**、**氨气浓度**四种气体浓度，检测**浓度取值范围**和**精度**取决于具体传感器。对于气体传感器，其检测精度均为`0.1ppm`。

    1）温湿度传感器

    - 温湿度包括`温度（temp）`和`湿度（humi）`，均为`float`数据类型，小数位数1位，量程湿度`5~95%RH`， 温度`-20~+60℃`。由于本传感器工作环境温度不会低于零度，因此`负数`读数表示传感器工作异常。

    2）臭氧

    - 包括`臭氧浓度（O3）`，量程`0~100ppm`，分辨率是`0.1ppm`。

    3）一氧化氮

    - 包括`氮氧化物浓度（NO）`，量程`0~2000ppm`，分辨率是`0.1ppm`。

    4）二氧化氮

    - 包括`氮氧化物浓度（NO2）`，量程`0~2000ppm`，分辨率是`0.1ppm`。

    5）氨气

    - 包括`氨气浓度（NH3）`，量程`0~1000ppm`，分辨率是`0.1ppm`。

#### **解析样例demo：**

```javascript
{
    "i_num":2,
    "per_mls":1000,
    "add":1,
    "temp":22.0,
    "humi":20.0
}
```

上位机接收后会在其中加入`当地时间戳（time）`，格式为`hhmmss`，如下所示:

```javascript
{
    "i_num":2,
    "p_mls":1000,
    "add":1,
    "temp":20.3,
    "humi":42,
    "time":"151536" // 15:15:36
}
```


## 三、上位机向下位机发信的协议

上位机向下位机发送的内容为：上位机向下位机发送指令，用以调整从传感器读数的采样间隔；

### 3.1 命令格式

指令为一个`字符串`，在下位机上存储的格式为`std::string`。

### 3.2 命令内容

首位字符为一大写字母，表明指令类型；第二个字符为数字，取值`0~9`，表明操作的传感器对象；第三个字符为地址位，是一个数字，取值`0~9`；对于调整采样间隔的命令，若第四位为`0`，则表明这是一个小数，注意不包含**小数点**；对于查询命令，仅返回长整型数的采样间隔。对于调整对应地址下位机传感器连接数量命令，该数量小于等于`4`。

- 首位字母

    - `"P"`:
        - 调整采样间隔，注意，时间单位为毫秒
    - `"S"`:
        - 调整传感器连接数量，该数量小于等于`4`
    - `"T"`: 发送文本信息
    - `"Q"`: 查询命令
        - 特别的，对于查询命令，应当避免回信的时候与定期传回的传感器数据同时调用函数，引起冲突。
        - 查询命令规定长度为4位，最后一位占位无实际意义。

- 第二位数字

    - `0`:  无指定传感器
    - `1`:  氨气传感器
    - `2`:  臭氧传感器
    - `3`:  一氧化氮传感器
    - `4`:  二氧化氮传感器
    - `5`:  温湿度传感器

- 第三位

    - 地址位 
        - 当地址位为`0`时，表明是向所有下位机发送。

- 第四位
  
    若为`0`，则说明是小数，后续无**小数点**。

#### **发信demo：**

```C
"P0105"             // 将地址1的从机的采样间隔调整为0.5s
"P010500"           // 将地址1的从机的采样间隔调整为0.5s
"P012000"           // 将地址1的从机的采样间隔调整为2s
"S014"              // 将地址1的从机询问的传感器数量改成4
"T01HelloWorld!"    // 向地址为1的从机发送文本"HelloWorld!"
"Q010"              // 向地址为1的从机询问当前采样时间间隔
```

## 四、硬件内部通信全局变量说明

本节只描述硬件的通信数据格式和通信时的细节要求，具体接线见技术手册。

### 4.1 发信间隔与全局变量

在程序内定义的`period_millis`，是发信间隔，也是从传感器获取数值的最小间隔。

如使用DHT等慢速传感器，则最小通信时间为`2秒`，因此，发信间隔不一定是传感器的询问时间。同样，温湿度数据不需要频繁更新，因此，对于温湿度设置一系列的全局变量，通过全局变量分别记录DHT传感器读数和上一次传感器读取时间，当时间间隔大于至少`2秒`后，再进行读写操作。

目前对DHT11读写设定时间间隔是`3000`毫秒。

同样，发信和读取传感器的实时数据也是分开的（异步），时间间隔同时调整发信的间隔和上位机问询传感器的时间间隔。初始的气体浓度均设为异常值。气体传感器通信方式与具体时间间隔见[第五章5.5节](#55-单片机与传感器之间的应答规范)。

### 4.2 调用发信函数的冲突协调

定期上报和查询发信同时需要调用发信函数，因此将查询发信间隔的回信设定在发信后的`20ms`之后，并至少距离下一次定期上报差`20ms`。需要设定发信函数调用的全局状态位。

## 五、单片机与气体传感器的通信

购买的传感器为485通信模块，因此采用Modbus通信协议。但目前来看，传感器可以同时进行两种操作。有待后续和商家的沟通。

### 5.1 通讯形式

传感器使用基于485的Modbus-RTU协议，编程使用软串口`HardwareSerial`初始化，使用方法见：

- https://blog.csdn.net/weixin_42618434/article/details/116019430
- ~/Arduino15/packages/esp32/hardware/esp32/2.0.2/cores/esp32/HardwareSerial.cpp

其中，`config`为校验停止位设置，其默认参数`SERIAL_8N1`为`8`为数据位，`N`没有校验位，`1`表示1个停止位，编程时需指定。

### 5.2 传感器通信基本参数

- 编码：        8位二进制
- 数据位：      8位
- 奇偶校验位：  无
- 停止位：      1位
- 错误校准：    CRC冗长循环码
- 波特率：      出厂默认9600bps

### 5.3 TTL通讯命令数据帧格式定义

在TTL协议中，可以有主动上报。传感器刚出厂时是默认开启主动上报模式的（包括485类），所以需要手动切换为询问模式。命令字应为`03`，手册有误。

#### （1）主动上报模式

起始位 | 地址 | 命令字 | 分辨率位 | 气体浓度 | - | - | - | 校验和
---|--- | ---|--- |--- |--- |--- |--- |--- 
0xFF  | 0x01 | 0x07   | 0x02    | 高字节+低字节| 0| 0| 0| 0x3a

对于分辨率：

分辨率位|分辨率系数
---     |---
0x01    |1
0x01    |0.1
0x02    |0.01
0x03    |0.001

对于校验和：

将各个字节加起来之后字节中尚未溢出的部分为校验和

命令字表示当前发送或接受的信息具体是哪种指令，`07`是传感器读数相关。

#### （2）询问模式

问询一次数据发送：

起始位 | 地址 | 命令字 | - | - | - | - | - | 校验和
---|--- | ---|--- |--- |--- |--- |--- |--- 
0xFF  | 0x01 | 0x07   | 0    | 0| 0| 0| 0| 0x07

单片机返回：

起始位 | 地址 | 命令字 | 分辨率位 | 气体浓度 | - | - | - | 校验和
---|--- | ---|--- |--- |--- |--- |--- |--- 
0xFF  | 0x01 | 0x07   | 0x02    | 高字节+低字节| 0| 0| 0| 0x3a

#### （3）修改上报模式

问询一次数据发送：

起始位 | 地址 | 命令字 | 通讯模式 | - | - | - | - | 校验和
---|--- | ---|--- |--- |--- |--- |--- |--- 
0xFF  | 0x01 | 0x03   | 0x02    | 0| 0| 0| 0| 0x05

单片机返回：

起始位 | 地址 | 命令字 | 分辨率位 | - | - | - | - | 校验和
---|--- | ---|--- |--- |--- |--- |--- |--- 
0xFF  | 0x01 | 0x03   | 0x01    | 0 | 0| 0| 0| 0x04

若要切换回主动上报模式，向传感器发送上面单片机返回的数据即可。

###  5.4 Modbus通信协议数据帧格式

对于Modbus-RTU协议，必须有问询才有回复。

- 初始结构大于等于4个字节的时间
- 地址码为`1`个字节
- 功能码为`1`个字节，表示当前是读操作还是写操作，读操作为`0x03`，写操作商家**未告知**，需要**用商家提供的软件来修改**
- 数据区为若干个字节，目前使用`2`个字节，在传回数据中会特别标注
- 错误校验为16位CRC
- 结束结构大于等于4个字节的时间

#### （1）地址位

寄存器地址| PLC组态地址 |   内容    |   可进行操作
---      |  ---     |       --- |   ---
0006H    | 40007    |  气体浓度 |   只读
0100H    | 40101    |   设备地址|   读写
0101H    | 40102    |   波特率  |   读写

上述地址位中，可进行读写操作的设备地址取值范围为`0~252`，波特率三档可调，为`2400`，`4800`，`9600`。

对于每个传感器，他们分别都有自己的地址位，严格按照上面表格的顺序分配地址位如下：

- 氨气传感器：      0x01；
- 臭氧传感器：      0x02；
- 一氧化氮传感器：  0x03；
- 二氧化氮传感器：  0x04；

首次使用前，**务必先修改各个传感器的地址位，否则将导致传感器彻底损坏**。

#### （2）读写示例

问询帧有`8`个字节长，应答帧有`7`个字节长。

- 问询帧

地址码| 功能码 |   起始地址    |   数据长度|校验码低位|校验码高位
---      |  ---     |       --- |   --- |    ---|    ---
0x01    |   0x03|   0x00,0x06|  0x00,0x01|  0x64|   0x0B

- 应答帧

地址码| 功能码 |   起始地址    |   数据长度|校验码低位|校验码高位
---      |  ---     |       --- |   --- |    ---|    ---
0x01    |   0x03|   0x02    |  0x00,0x10|  0x78|   0x35

#### （3）CRC校验码生成方法

已封装为函数，不清楚具体算法。函数传入参数包括字符串的指针和需要计算CRC16的前`n`位数据，返回数据为两个字节长的无符号整型数。在本装置中，需要计算的数据应是校验位之前全部数据，对于问询帧，总共有`6`位数据。

封装如下：

```C++
/* CRC16 计算函数，ptr-数据指针，len-数据长度，返回值-计算出的 CRC16 数值 */ 
uint16_t GetCRC16(uint8_t *ptr, uint8_t len)
{
  uint16_t index;
  uint8_t crch = 0xFF; // 高 CRC 字节 
  uint8_t crcl = 0xFF; // 低 CRC 字节
  uint8_t TabH[] = { // CRC 高位字节值表
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 
    0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
    0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 
    0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
    0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
    0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 
    0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 
    0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
    0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
    0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 
    0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
    0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 
    0xC1, 0x81, 0x40
  };
  uint8_t TabL[] = { // CRC 低位字节值表
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 
    0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 
    0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 
    0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 
    0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 
    0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 
    0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 
    0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 
    0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 
    0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 
    0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 
    0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 
    0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 
    0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 
    0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
    0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 
    0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 
    0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 
    0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 
    0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 
    0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 
    0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 0x44, 0x84, 
    0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 
    0x81, 0x80, 0x40
  };
  while(len--) //计算指定长度的CRC 
  {
    index = crch ^ *ptr++; 
    crch = crcl ^ TabH[index]; 
    crcl = TabL[index];
  }
  return ((crch << 8) | crcl); // 将高字节左移八位，与低字节位或（拼在一起）
}
```

这里给出具体的生成操作和拆分成两个字节的方法：

``` C++
int main(){
    // 生成
    unsigned char request_for_sensor_command[8] = {0x01, 0x03, 0x00, 0x06, 0x00, 0x01, 0x64, 0x0B}; 
    printf("\n\n%x\n\n", GetCRC16(request_for_sensor_command, 6));
    // OUTPUT: 640b

    // 将uint16拆分成两个无符号字节
    unsigned int crcInt = GetCRC16(request_for_sensor_command, 6);
    unsigned char crcl = crcInt;
    unsigned char crch = crcInt >> 8;
    printf("high byte: %x,\t low byte:%x\n\n",  crch, crcl);
    // OUTPUT: high byte: 64,	 low byte:b
    return 0;
}
```

因此每个传感器对应的CRC校验码为：

- 氨气传感器：`640bH`
- 臭氧传感器：`6438H`
- NO传感器：  `65e9H`
- NO2传感器： `645eH`

### 5.5 单片机与传感器之间的应答规范

单片机向传感器发信，经过一定时间后，单片机应收到传感器回信。这一过程需要设置超时，若超出一定时间仍未收到，则单片机返回两位异常值`0xFFFF`；收到返回数据之后，单片机需要对收到的数据进行计算检验，若校验失败，则仍需返回约定的异常值`0xFFFF`。

#### 超时设置

目前实测，发信后间隔大于`10毫秒`才能收到回信，未测试具体返回时间。目前设等待的超时时间为`50毫秒`。

与气体传感器的通信采用轮询的方式，每个传感器之间询问时间间隔`50ms`，四个传感器轮询总耗时最长约`200ms`（这一时间包括最后一个传感器返回的时间），这一总耗时在预设的最短查询时间`500ms`以下，与整体设计参数不冲突。原本希望轮询时屏蔽下位机向蓝牙上位机发信，等待超时后再向上位机发信，控制总时间尽可能接近并不超过设定的发信周期，实际操作中发现这样会导致上传时延较大，造成数据积压。因此轮询时不再屏蔽，而是单独设置每次查询时设为`-1`。